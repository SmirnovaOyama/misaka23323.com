> paste 备份：https://paste.sheartm.com/aaaaaac1
## 8.1 面向对象程序设计基础

### 8.1.1 对象、封装与 OOP

1. **对象（object）**

   * 一个对象由 **属性（数据）** 和 **行为（操作）** 两部分组成。
   * 对象能够根据外界给出的信息，执行相应的功能。

2. **封装（encapsulation）与信息隐蔽**

   * 把对象的一部分属性和功能对外隐藏，使外界不能直接访问。
   * 外部只能通过类提供的“**接口**”与对象交互，而不能直接操作内部数据。
   * 好处：

     * 保证数据安全；
     * 降低模块之间的耦合；
     * 便于维护和升级实现而不影响外部调用。

3. **面向对象设计 / 编程**

   * **OOD（Object Oriented Design）**：用对象的思想进行软件设计。
   * **OOP（Object Oriented Programming）**：用面向对象语言（C++ 等）去实现设计。
   * C++ 既支持：

     * **面向过程风格**：以函数为中心组织程序；
     * **面向对象风格**：以类和对象为中心组织程序。

---

## 8.2 类的声明和对象的定义

### 8.2.1 类和对象的关系

* C++ 中，对象的“类型”称为 **类（class）**。
* **类是对象的抽象**，**对象是类的具体实例（instance）**。
* 类本身只是一个类型说明，是一种“模板”，**不占用具体数据存储空间**。
* 只有在 **定义对象** 时，系统才为对象的 **数据成员** 分配内存。

可类比理解：

* 结构体类型 vs 结构体变量
* 类类型 vs 类的对象

---

### 8.2.2 类的声明形式与访问控制

#### 1. 最基本的类声明示例

```cpp
#include <iostream>
using namespace std;

class Student {
    int num;
    char name[20];
    char sex;      // 以上 3 个是数据成员

    void display() {   // 成员函数
        cout << "num:"  << num  << endl;
        cout << "name:" << name << endl;
        cout << "sex:"  << sex  << endl;
    }
};
```

* 这里没有写 `public` / `private`，因此成员的默认访问权限是 **private**（C++ 规定）。

#### 2. 一般类的标准声明形式

```cpp
class 类名 {
private:
    // 私有数据成员和私有成员函数
    // 只能在类的内部（成员函数）访问，类外不能直接访问

public:
    // 公有数据成员和公有成员函数
    // 在类内、类外都可以访问，是对外开放的接口
};
```

* **访问限定符（access specifier）**：

  * `private`：私有成员；
  * `public`：公有成员；
  * `protected`：受保护成员（与继承更相关，本章知道名字即可）。
* 一个类体内部可以多次使用 `private:` / `public:`，每次自该关键字起直至下一个限定符或类结束。

#### 3. 使用访问控制改写 `Student` 类

```cpp
#include <iostream>
using namespace std;

class Student {
private:      // 以下为私有成员
    int  num;
    char name[20];
    char sex;

public:      // 以下为公有成员（接口）
    void display() {
        cout << "num:"  << num  << endl;
        cout << "name:" << name << endl;
        cout << "sex:"  << sex  << endl;
    }
};
```

---

### 8.2.3 定义对象（object）

当定义对象时，系统开始为对象分配空间，用于存放该对象的 **数据成员**。

#### 1. 先声明类类型，再定义对象

```cpp
class Student {
    // ...
};

Student s1, s2;         // 推荐写法
// 或者：class Student s1, s2;   // 也可以，只是较少这样写
```

* `Student` 是类类型，`s1`、`s2` 是该类型的两个对象。

#### 2. 声明类类型的同时定义对象

```cpp
#include <iostream>
using namespace std;

class Student {          // 声明类类型
public:
    void display() {
        cout << "num:"  << num  << endl;
        cout << "name:" << name << endl;
        cout << "sex:"  << sex  << endl;
    }

private:
    int  num;
    char name[20];
    char sex;
} s1, s2;               // 在类体结束的分号前定义两个对象
```

> 注意：类体最后的 `};` 之前允许紧接对象声明列表。

#### 3. 没有类名的匿名类对象（不推荐）

```cpp
class {          // 没有类名
private:
    // ...
public:
    // ...
} s1, s2;        // 定义两个匿名类的对象
```

* 实际开发几乎不用这种形式。

---

### 8.2.4 类与结构体类型的异同

* 在 C++ 中，`struct` 也可以有 **成员函数**，与 `class` 在语法能力上几乎等价。
* 唯一语义差别：

  * `struct` 的默认访问权限是 **public**；
  * `class` 的默认访问权限是 **private**。
* 实际编程中，为了强调面向对象风格，一般使用 `class` 定义类。

---

## 8.3 类的成员函数

### 8.3.1 成员函数的性质

* 成员函数与一般函数的主要区别在于：它是 **某个类的成员**。
* 是否能在类外调用，取决于：

  * 它本身是否声明为 `public`；
  * 它所在类中被访问的其它成员是否允许。
* **私有成员函数（private）**：只能被本类的其他成员函数调用，类外不能直接调用。
* 成员函数可以访问本类的 **所有成员**（包括 `private` 和 `public`）。

---

### 8.3.2 在类外定义成员函数（作用域运算符 `::`）

#### 1. 类内只做声明，类外再定义

```cpp
#include <iostream>
using namespace std;

class Student {
public:
    void display();   // 只声明，不给出函数体

private:
    int    num;
    string name;
    char   sex;
};

// 在类外定义成员函数，使用作用域运算符 ::
void Student::display() {
    cout << "num:"  << num  << endl;
    cout << "name:" << name << endl;
    cout << "sex:"  << sex  << endl;
}
```

关键点：

* 在类外定义成员函数时，必须写 **`类名::函数名`**，用 `::` 指明属于哪个类。
* 写成 `display()` 或 `::display()`（没有类名）时，它就是一个普通函数，不再是该类成员。
* 类的完整定义必须出现在成员函数定义之前，否则编译器不知道 `Student` 是什么。

---

### 8.3.3 `inline` 成员函数

#### 1. 一般内联函数

* **内联函数（inline）**：在调用处直接把函数体代码“嵌入”进去，从而减少函数调用开销（是否真正内联由编译器决定）。

```cpp
inline int add(int a, int b) {
    return a + b;
}
```

#### 2. 类内定义的成员函数默认倾向被视为 `inline`

```cpp
class Student {
public:
    void display() {   // 类内定义，一般视为 inline
        cout << "num:"  << num  << endl;
        cout << "name:" << name << endl;
        cout << "sex:"  << sex  << endl;
    }

private:
    int    num;
    string name;
    char   sex;
};
```

* 即使不写 `inline`，类内定义的成员函数通常会作为内联候选。

#### 3. 类外定义的成员函数若想内联，需要显式 `inline`

```cpp
class Student {
public:
    inline void display();   // 声明时可以加 inline

private:
    int    num;
    string name;
    char   sex;
};

// 定义时同样可以写 inline（声明和定义任一处写上即可）
inline void Student::display() {
    cout << "num:"  << num  << endl;
    cout << "name:" << name << endl;
    cout << "sex:"  << sex  << endl;
}
```

> 实践要点：为了真正实现内联，类的定义与内联成员函数的 **函数体** 一般都放在头文件中，这样在所有调用处编译器都能看到函数实现，从而进行内联展开。

---

### 8.3.4 成员函数的存储方式与对象大小

* 对于同一个类的所有对象，**成员函数的代码只存一份**。
* 每个对象只占有自己的 **数据成员** 空间。
* 成员函数的指令代码不存放在对象内部，而是所有对象共享。

示例 `Time` 类（简化版）：

```cpp
#include <iostream>
using namespace std;

class Time {
public:
    int hour;
    int minute;
    int sec;

    void set() {
        cin >> hour >> minute >> sec;
    }
};

int main() {
    cout << sizeof(Time) << endl;    // 一般为 12 字节（具体依实现而定）
    return 0;
}
```

* 说明：`sizeof(Time)` 只计算数据成员的大小，与有多少成员函数无关。

---

### 8.3.5 `this` 指针

* 成员函数“为某个对象服务”，但代码只存一份。
* C++ 在调用成员函数时，会隐式传入一个参数 `this`，它是指向 **当前对象** 的指针。
* 成员函数中访问数据成员，实际上等价于使用 `this->成员名`。
* 一般写法可以省略 `this->`，但在成员名与形式参数重名时，可以通过 `this->` 消除歧义。

---

## 8.4 对象成员的引用（访问对象中成员）

访问对象的成员主要有三种方式：

1. 通过 **对象名 + `.` 成员运算符**；
2. 通过 **指向对象的指针 + `->` 或 `(*p).成员`**；
3. 通过 **对象的引用变量 + `.`**。

---

### 8.4.1 通过对象名和成员运算符访问

#### 1. 语法形式

```cpp
对象名.成员名
```

示例（假设 `num` 是公有成员）：

```cpp
#include <iostream>
using namespace std;

class Student {
public:
    int num;
    void display() {
        cout << "num:" << num << endl;
    }
};

int main() {
    Student s1;
    s1.num = 1001;   // 访问公有数据成员
    s1.display();    // 调用公有成员函数
    // display();    // 错误：未指明是哪个对象的 display
    return 0;
}
```

#### 2. 公有 / 私有成员的限制

* 在 **类外** 仅能访问对象的 **公有成员**。
* 若 `num` 是 `private`，则：

```cpp
s1.num = 1001;   // 错误：num 是 private，类外不可直接访问
```

* 在类外也只能调用 **公有成员函数**，不能直接调用私有成员函数。

---

### 8.4.2 通过指向对象的指针访问

#### 1. 基本形式

```cpp
指针名->成员名
(*指针名).成员名
```

示例（`Time` 类）：

```cpp
#include <iostream>
using namespace std;

class Time {
public:
    int hour;
    int minute;
};

int main() {
    Time t;
    Time* p = nullptr;

    p = &t;        // p 指向对象 t

    p->hour = 1;   // 等价于 (*p).hour = 1; 也等价于 t.hour = 1;

    cout << p->hour   << endl;
    cout << (*p).hour << endl;
    cout << t.hour    << endl;

    return 0;
}
```

* 在 `p` 指向 `t` 时，`p->hour`、`(*p).hour`、`t.hour` 表示同一个内存单元。

---

### 8.4.3 通过引用变量访问对象成员

* **引用（reference）** 是某个变量或对象的“别名”。

```cpp
#include <iostream>
using namespace std;

class Time {
public:
    int hour;
    int minute;
};

int main() {
    Time t1;
    t1.hour = 10;

    Time& t2 = t1;      // t2 是 t1 的引用

    cout << t2.hour << endl;   // 实际访问的是 t1.hour

    t2.hour = 20;              // 修改 t2.hour
    cout << t1.hour << endl;   // 输出 20

    return 0;
}
```

* 因为 `t2` 和 `t1` 是同一块内存的两个名字，所以对任一一方的修改都会反映到另一方。

---

## 8.5 类的封装性和信息隐蔽

### 8.5.1 公共接口与私有实现

* 把数据和函数统一封装在类中，通过访问控制实现“保护”，这就是 **封装性**。
* 外部使用类时，主要依赖 **公有成员函数** 提供的功能。
* 公有成员函数是类对外的“**接口（interface）**”，私有数据和私有函数是“**实现（implementation）**”。

典型用法：

* 私有数据成员不允许被外部随意改动；
* 外部只能通过类提供的公有成员函数间接读写这些数据；
* 这样既保证安全，又便于未来更改实现方式而不影响调用代码。

---

### 8.5.2 类声明与成员函数定义的分离（.h / .cpp）

在实际工程中，为了模块化和复用，通常采用 **头文件 + 源文件** 的组织方式：

1. **头文件 `student.h`** —— 声明类

```cpp
// student.h
#ifndef STUDENT_H
#define STUDENT_H

class Student {
public:
    void display();   // 只声明原型

private:
    int num;
};

#endif // STUDENT_H
```

2. **实现文件 `student.cpp`** —— 定义成员函数

```cpp
// student.cpp
#include <iostream>
using namespace std;

#include "student.h"   // 一定要包含头文件，保证类型一致

void Student::display() {
    cout << "num:" << num << endl;
}
```

3. **主程序 `main.cpp`** —— 使用类

```cpp
// main.cpp
#include "student.h"   // 包含类声明

int main() {
    Student s;        // 定义对象
    s.display();      // 调用成员函数
    return 0;
}
```

4. **`#include` 的双引号与尖括号**

* `"student.h"`：优先在当前工程目录中查找该文件；
* `<xxx>`：一般用于标准库或系统头文件，编译器在系统路径中查找。

5. **inline 成员函数与头文件**

* 若成员函数被声明为 `inline`，则其定义通常也放在头文件中；
* 最常见写法是：直接在类内定义该成员函数。

---

### 8.5.3 相关术语

* **方法（method）**：面向对象语境下对“成员函数”的常用称呼。
* **消息（message）**：向对象发送的“请求”，在 C++ 中体现为“对对象成员函数的一次调用”。

---

## 8.6 类和对象的应用示例

### 8.6.1 使用普通函数操作结构体 `Time`（面向过程风格）

先看非面向对象写法：

```cpp
#include <iostream>
using namespace std;

struct Time {
    int hour;
    int minute;
};

// 函数声明
void set_time(Time& t);
void show_time(Time& t);

int main() {
    Time t1;
    set_time(t1);
    show_time(t1);

    return 0;
}

// 函数定义
void set_time(Time& t) {
    cin >> t.hour >> t.minute;    // 输入时间
}

void show_time(Time& t) {
    cout << t.hour << ":" << t.minute << endl;
}
```

* 这里 `Time` 只是一个简单结构体，`set_time`、`show_time` 是独立的普通函数。
* 整体设计方式仍然偏向 **面向过程**：数据和操作是分离的。

#### 加上默认参数的版本

```cpp
#include <iostream>
using namespace std;

struct Time {
    int hour;
    int minute;
};

// 带默认参数的函数声明
void set_time(Time& t, int h = 0, int m = 0);
void show_time(Time& t);

int main() {
    Time t1;
    set_time(t1, 12, 23);
    show_time(t1);      // 输出 12:23

    Time t2;
    set_time(t2);       // 使用默认参数（0, 0）
    show_time(t2);      // 输出 0:0

    return 0;
}

void set_time(Time& t, int h, int m) {
    t.hour   = h;
    t.minute = m;
}

void show_time(Time& t) {
    cout << t.hour << ":" << t.minute << endl;
}
```

---

### 8.6.2 改写为含成员函数的 `Time` 类（面向对象风格）

现在把数据与操作统一封装到类中：

```cpp
#include <iostream>
using namespace std;

class Time {
public:
    void set_time() {          // 也可以在类外定义，这里为简明直接写在类内
        cin >> hour >> minute;
    }

    void show_time() {
        cout << hour << ":" << minute << endl;
    }

private:
    int hour;
    int minute;
};

int main() {
    Time t1;          // 定义对象 t1
    t1.set_time();    // 通过对象调用成员函数设置时间
    t1.show_time();   // 通过对象调用成员函数显示时间

    return 0;
}
```

要点：

1. 数据 `hour`，`minute` 和操作 `set_time`，`show_time` 被封装在一个类 `Time` 内。
2. 在 `main` 中，必须以 `对象名.成员函数()` 形式调用，例如 `t1.set_time()`，不能简单写 `set_time()`，否则编译器不知道是操作哪个对象。
3. 成员函数内部访问本对象数据成员时，一般直接写名字即可，比如 `hour`；等价于 `this->hour`。

---

### 8.6.3 示例：求数组最大值的 `Arraymax` 类

完整定义如下：

```cpp
#include <iostream>
using namespace std;

class Arraymax {
public:
    void setvalue();   // 对数组元素设置值
    void maxvalue();   // 求数组中的最大元素
    void showvalue();  // 输出最大值

private:
    int array[10];     // 整型数组
    int max;           // 存放最大值
};

void Arraymax::setvalue() {
    for (int i = 0; i < 10; ++i) {
        cin >> array[i];
    }
}

void Arraymax::maxvalue() {
    max = array[0];
    for (int i = 1; i < 10; ++i) {
        if (array[i] > max) {
            max = array[i];
        }
    }
}

void Arraymax::showvalue() {
    cout << "max=" << max << endl;
}

int main() {
    Arraymax a;      // 定义对象

    a.setvalue();    // 输入数组元素
    a.maxvalue();    // 求最大值
    a.showvalue();   // 输出最大值

    return 0;
}
```

分析要点：

* 将 **数组 + 相关操作（输入、求最大值、输出）** 封装在 `Arraymax` 类中。
* 外部只需要：

  * 创建对象 `Arraymax a;`
  * 按顺序调用 `a.setvalue()`、`a.maxvalue()`、`a.showvalue()` 即可。
* 内部如何存储数组、如何比较求最大值，对使用者都是透明的，体现了 **封装（数据与操作一体化）** 和 **信息隐蔽（只暴露必要接口）**。

---

## 8.7 静态库示例（头文件 + 库文件的接口/实现分离）

最后看一个关于静态库的小例子，用来展示头文件与库文件的配合方式。

### 8.7.1 头文件 `rqm.h`

```cpp
// rqm.h
#include <iostream>
using namespace std;

extern int i;   // 在其他编译单元中定义的全局变量

void f1();
int  f2();
```

### 8.7.2 库实现文件（生成 `rqm.lib`）

```cpp
// rqm.cpp
#include "rqm.h"

int i = 100;

void f1() {
    cout << "OK!" << endl;
}

int f2() {
    return i + 9;
}
```

* 把这个工程编译为静态库 `rqm.lib`；
* 将 `rqm.lib` 与 `rqm.h` 放到某个目录（例如 `C:/rqm`）备用。

### 8.7.3 在另一个工程中使用静态库

```cpp
// 测试工程 main.cpp
#include <iostream>
using namespace std;

#include "C:/rqm/rqm.h"
#pragma comment (lib, "C:/rqm/rqm.lib")   // 告诉链接器要链接此库

int main() {
    f1();              // 调用库中的函数
    cout << i  << endl;
    cout << f2() << endl;
    return 0;
}
```

要点小结：

* 通过 `#include "rqm.h"` 让编译器了解函数和变量的声明；
* 通过 `#pragma comment(lib, "...")` 或工程设置，将 `rqm.lib` 链接进最终可执行程序；
* 整体思想与类的封装类比：

  * 头文件提供“接口声明”；
  * 库文件或源文件中隐藏具体实现。

---


