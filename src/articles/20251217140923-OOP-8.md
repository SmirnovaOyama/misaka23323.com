> paste 备份：https://paste.sheartm.com/aaaaaac1
## 8.1 面向对象程序设计基础

### 8.1.1 对象、封装与 OOP

1. **对象（object）**

   * 一个对象由 **属性（数据）** 和 **行为（操作）** 两部分组成。
   * 对象能够根据外界给出的信息，执行相应的功能。

2. **封装（encapsulation）与信息隐蔽**

   * 把对象的一部分属性和功能对外隐藏，使外界不能直接访问。
   * 外部只能通过类提供的“**接口**”与对象交互，而不能直接操作内部数据。
   * 好处：

     * 保证数据安全；
     * 降低模块之间的耦合；
     * 便于维护和升级实现而不影响外部调用。

3. **面向对象设计 / 编程**

   * **OOD（Object Oriented Design）**：用对象的思想进行软件设计。
   * **OOP（Object Oriented Programming）**：用面向对象语言（C++ 等）去实现设计。
   * C++ 既支持：

     * **面向过程风格**：以函数为中心组织程序；
     * **面向对象风格**：以类和对象为中心组织程序。

---

## 8.2 类的声明和对象的定义

### 8.2.1 类和对象的关系

* C++ 中，对象的“类型”称为 **类（class）**。
* **类是对象的抽象**，**对象是类的具体实例（instance）**。
* 类本身只是一个类型说明，是一种“模板”，**不占用具体数据存储空间**。
* 只有在 **定义对象** 时，系统才为对象的 **数据成员** 分配内存。

可类比理解：

* 结构体类型 vs 结构体变量
* 类类型 vs 类的对象

---

### 8.2.2 类的声明形式与访问控制

#### 1. 最基本的类声明示例

```cpp
#include <iostream>
using namespace std;

class Student {
    int num;
    char name[20];
    char sex;      // 以上 3 个是数据成员

    void display() {   // 成员函数
        cout << "num:"  << num  << endl;
        cout << "name:" << name << endl;
        cout << "sex:"  << sex  << endl;
    }
};
```

* 这里没有写 `public` / `private`，因此成员的默认访问权限是 **private**（C++ 规定）。

#### 2. 一般类的标准声明形式

```cpp
class 类名 {
private:
    // 私有数据成员和私有成员函数
    // 只能在类的内部（成员函数）访问，类外不能直接访问

public:
    // 公有数据成员和公有成员函数
    // 在类内、类外都可以访问，是对外开放的接口
};
```

* **访问限定符（access specifier）**：

  * `private`：私有成员；
  * `public`：公有成员；
  * `protected`：受保护成员（与继承更相关，本章知道名字即可）。
* 一个类体内部可以多次使用 `private:` / `public:`，每次自该关键字起直至下一个限定符或类结束。

#### 3. 使用访问控制改写 `Student` 类

```cpp
#include <iostream>
using namespace std;

class Student {
private:      // 以下为私有成员
    int  num;
    char name[20];
    char sex;

public:      // 以下为公有成员（接口）
    void display() {
        cout << "num:"  << num  << endl;
        cout << "name:" << name << endl;
        cout << "sex:"  << sex  << endl;
    }
};
```

---

### 8.2.3 定义对象（object）

当定义对象时，系统开始为对象分配空间，用于存放该对象的 **数据成员**。

#### 1. 先声明类类型，再定义对象

```cpp
class Student {
    // ...
};

Student s1, s2;         // 推荐写法
// 或者：class Student s1, s2;   // 也可以，只是较少这样写
```

* `Student` 是类类型，`s1`、`s2` 是该类型的两个对象。

#### 2. 声明类类型的同时定义对象

```cpp
#include <iostream>
using namespace std;

class Student {          // 声明类类型
public:
    void display() {
        cout << "num:"  << num  << endl;
        cout << "name:" << name << endl;
        cout << "sex:"  << sex  << endl;
    }

private:
    int  num;
    char name[20];
    char sex;
} s1, s2;               // 在类体结束的分号前定义两个对象
```

> 注意：类体最后的 `};` 之前允许紧接对象声明列表。

#### 3. 没有类名的匿名类对象（不推荐）

```cpp
class {          // 没有类名
private:
    // ...
public:
    // ...
} s1, s2;        // 定义两个匿名类的对象
```

* 实际开发几乎不用这种形式。

---

### 8.2.4 类与结构体类型的异同

* 在 C++ 中，`struct` 也可以有 **成员函数**，与 `class` 在语法能力上几乎等价。
* 唯一语义差别：

  * `struct` 的默认访问权限是 **public**；
  * `class` 的默认访问权限是 **private**。
* 实际编程中，为了强调面向对象风格，一般使用 `class` 定义类。

---

## 8.3 类的成员函数

### 8.3.1 成员函数的性质

* 成员函数与一般函数的主要区别在于：它是 **某个类的成员**。
* 是否能在类外调用，取决于：

  * 它本身是否声明为 `public`；
  * 它所在类中被访问的其它成员是否允许。
* **私有成员函数（private）**：只能被本类的其他成员函数调用，类外不能直接调用。
* 成员函数可以访问本类的 **所有成员**（包括 `private` 和 `public`）。

---

### 8.3.2 在类外定义成员函数（作用域运算符 `::`）

#### 1. 类内只做声明，类外再定义

```cpp
#include <iostream>
using namespace std;

class Student {
public:
    void display();   // 只声明，不给出函数体

private:
    int    num;
    string name;
    char   sex;
};

// 在类外定义成员函数，使用作用域运算符 ::
void Student::display() {
    cout << "num:"  << num  << endl;
    cout << "name:" << name << endl;
    cout << "sex:"  << sex  << endl;
}
```

关键点：

* 在类外定义成员函数时，必须写 **`类名::函数名`**，用 `::` 指明属于哪个类。
* 写成 `display()` 或 `::display()`（没有类名）时，它就是一个普通函数，不再是该类成员。
* 类的完整定义必须出现在成员函数定义之前，否则编译器不知道 `Student` 是什么。

---

### 8.3.3 `inline` 成员函数

#### 1. 一般内联函数

* **内联函数（inline）**：在调用处直接把函数体代码“嵌入”进去，从而减少函数调用开销（是否真正内联由编译器决定）。

```cpp
inline int add(int a, int b) {
    return a + b;
}
```

#### 2. 类内定义的成员函数默认倾向被视为 `inline`

```cpp
class Student {
public:
    void display() {   // 类内定义，一般视为 inline
        cout << "num:"  << num  << endl;
        cout << "name:" << name << endl;
        cout << "sex:"  << sex  << endl;
    }

private:
    int    num;
    string name;
    char   sex;
};
```

* 即使不写 `inline`，类内定义的成员函数通常会作为内联候选。

#### 3. 类外定义的成员函数若想内联，需要显式 `inline`

```cpp
class Student {
public:
    inline void display();   // 声明时可以加 inline

private:
    int    num;
    string name;
    char   sex;
};

// 定义时同样可以写 inline（声明和定义任一处写上即可）
inline void Student::display() {
    cout << "num:"  << num  << endl;
    cout << "name:" << name << endl;
    cout << "sex:"  << sex  << endl;
}
```

> 实践要点：为了真正实现内联，类的定义与内联成员函数的 **函数体** 一般都放在头文件中，这样在所有调用处编译器都能看到函数实现，从而进行内联展开。

---

### 8.3.4 成员函数的存储方式与对象大小

* 对于同一个类的所有对象，**成员函数的代码只存一份**。
* 每个对象只占有自己的 **数据成员** 空间。
* 成员函数的指令代码不存放在对象内部，而是所有对象共享。

示例 `Time` 类（简化版）：

```cpp
#include <iostream>
using namespace std;

class Time {
public:
    int hour;
    int minute;
    int sec;

    void set() {
        cin >> hour >> minute >> sec;
    }
};

int main() {
    cout << sizeof(Time) << endl;    // 一般为 12 字节（具体依实现而定）
    return 0;
}
```

* 说明：`sizeof(Time)` 只计算数据成员的大小，与有多少成员函数无关。

---

### 8.3.5 `this` 指针

* 成员函数“为某个对象服务”，但代码只存一份。
* C++ 在调用成员函数时，会隐式传入一个参数 `this`，它是指向 **当前对象** 的指针。
* 成员函数中访问数据成员，实际上等价于使用 `this->成员名`。
* 一般写法可以省略 `this->`，但在成员名与形式参数重名时，可以通过 `this->` 消除歧义。

---

## 8.4 对象成员的引用（访问对象中成员）

访问对象的成员主要有三种方式：

1. 通过 **对象名 + `.` 成员运算符**；
2. 通过 **指向对象的指针 + `->` 或 `(*p).成员`**；
3. 通过 **对象的引用变量 + `.`**。

---

### 8.4.1 通过对象名和成员运算符访问

#### 1. 语法形式

```cpp
对象名.成员名
```

示例（假设 `num` 是公有成员）：

```cpp
#include <iostream>
using namespace std;

class Student {
public:
    int num;
    void display() {
        cout << "num:" << num << endl;
    }
};

int main() {
    Student s1;
    s1.num = 1001;   // 访问公有数据成员
    s1.display();    // 调用公有成员函数
    // display();    // 错误：未指明是哪个对象的 display
    return 0;
}
```

#### 2. 公有 / 私有成员的限制

* 在 **类外** 仅能访问对象的 **公有成员**。
* 若 `num` 是 `private`，则：

```cpp
s1.num = 1001;   // 错误：num 是 private，类外不可直接访问
```

* 在类外也只能调用 **公有成员函数**，不能直接调用私有成员函数。

---

### 8.4.2 通过指向对象的指针访问

#### 1. 基本形式

```cpp
指针名->成员名
(*指针名).成员名
```

示例（`Time` 类）：

```cpp
#include <iostream>
using namespace std;

class Time {
public:
    int hour;
    int minute;
};

int main() {
    Time t;
    Time* p = nullptr;

    p = &t;        // p 指向对象 t

    p->hour = 1;   // 等价于 (*p).hour = 1; 也等价于 t.hour = 1;

    cout << p->hour   << endl;
    cout << (*p).hour << endl;
    cout << t.hour    << endl;

    return 0;
}
```

* 在 `p` 指向 `t` 时，`p->hour`、`(*p).hour`、`t.hour` 表示同一个内存单元。

---

### 8.4.3 通过引用变量访问对象成员

* **引用（reference）** 是某个变量或对象的“别名”。

```cpp
#include <iostream>
using namespace std;

class Time {
public:
    int hour;
    int minute;
};

int main() {
    Time t1;
    t1.hour = 10;

    Time& t2 = t1;      // t2 是 t1 的引用

    cout << t2.hour << endl;   // 实际访问的是 t1.hour

    t2.hour = 20;              // 修改 t2.hour
    cout << t1.hour << endl;   // 输出 20

    return 0;
}
```

* 因为 `t2` 和 `t1` 是同一块内存的两个名字，所以对任一一方的修改都会反映到另一方。

---

## 8.5 类的封装性和信息隐蔽

### 8.5.1 公共接口与私有实现

* 把数据和函数统一封装在类中，通过访问控制实现“保护”，这就是 **封装性**。
* 外部使用类时，主要依赖 **公有成员函数** 提供的功能。
* 公有成员函数是类对外的“**接口（interface）**”，私有数据和私有函数是“**实现（implementation）**”。

典型用法：

* 私有数据成员不允许被外部随意改动；
* 外部只能通过类提供的公有成员函数间接读写这些数据；
* 这样既保证安全，又便于未来更改实现方式而不影响调用代码。

---

### 8.5.2 类声明与成员函数定义的分离（.h / .cpp）

在实际工程中，为了模块化和复用，通常采用 **头文件 + 源文件** 的组织方式：

1. **头文件 `student.h`** —— 声明类

```cpp
// student.h
#ifndef STUDENT_H
#define STUDENT_H

class Student {
public:
    void display();   // 只声明原型

private:
    int num;
};

#endif // STUDENT_H
```

2. **实现文件 `student.cpp`** —— 定义成员函数

```cpp
// student.cpp
#include <iostream>
using namespace std;

#include "student.h"   // 一定要包含头文件，保证类型一致

void Student::display() {
    cout << "num:" << num << endl;
}
```

3. **主程序 `main.cpp`** —— 使用类

```cpp
// main.cpp
#include "student.h"   // 包含类声明

int main() {
    Student s;        // 定义对象
    s.display();      // 调用成员函数
    return 0;
}
```

4. **`#include` 的双引号与尖括号**

* `"student.h"`：优先在当前工程目录中查找该文件；
* `<xxx>`：一般用于标准库或系统头文件，编译器在系统路径中查找。

5. **inline 成员函数与头文件**

* 若成员函数被声明为 `inline`，则其定义通常也放在头文件中；
* 最常见写法是：直接在类内定义该成员函数。

---

### 8.5.3 相关术语

* **方法（method）**：面向对象语境下对“成员函数”的常用称呼。
* **消息（message）**：向对象发送的“请求”，在 C++ 中体现为“对对象成员函数的一次调用”。

---

## 8.6 类和对象的应用示例

### 8.6.1 使用普通函数操作结构体 `Time`（面向过程风格）

先看非面向对象写法：

```cpp
#include <iostream>
using namespace std;

struct Time {
    int hour;
    int minute;
};

// 函数声明
void set_time(Time& t);
void show_time(Time& t);

int main() {
    Time t1;
    set_time(t1);
    show_time(t1);

    return 0;
}

// 函数定义
void set_time(Time& t) {
    cin >> t.hour >> t.minute;    // 输入时间
}

void show_time(Time& t) {
    cout << t.hour << ":" << t.minute << endl;
}
```

* 这里 `Time` 只是一个简单结构体，`set_time`、`show_time` 是独立的普通函数。
* 整体设计方式仍然偏向 **面向过程**：数据和操作是分离的。

#### 加上默认参数的版本

```cpp
#include <iostream>
using namespace std;

struct Time {
    int hour;
    int minute;
};

// 带默认参数的函数声明
void set_time(Time& t, int h = 0, int m = 0);
void show_time(Time& t);

int main() {
    Time t1;
    set_time(t1, 12, 23);
    show_time(t1);      // 输出 12:23

    Time t2;
    set_time(t2);       // 使用默认参数（0, 0）
    show_time(t2);      // 输出 0:0

    return 0;
}

void set_time(Time& t, int h, int m) {
    t.hour   = h;
    t.minute = m;
}

void show_time(Time& t) {
    cout << t.hour << ":" << t.minute << endl;
}
```

---

### 8.6.2 改写为含成员函数的 `Time` 类（面向对象风格）

现在把数据与操作统一封装到类中：

```cpp
#include <iostream>
using namespace std;

class Time {
public:
    void set_time() {          // 也可以在类外定义，这里为简明直接写在类内
        cin >> hour >> minute;
    }

    void show_time() {
        cout << hour << ":" << minute << endl;
    }

private:
    int hour;
    int minute;
};

int main() {
    Time t1;          // 定义对象 t1
    t1.set_time();    // 通过对象调用成员函数设置时间
    t1.show_time();   // 通过对象调用成员函数显示时间

    return 0;
}
```

要点：

1. 数据 `hour`，`minute` 和操作 `set_time`，`show_time` 被封装在一个类 `Time` 内。
2. 在 `main` 中，必须以 `对象名.成员函数()` 形式调用，例如 `t1.set_time()`，不能简单写 `set_time()`，否则编译器不知道是操作哪个对象。
3. 成员函数内部访问本对象数据成员时，一般直接写名字即可，比如 `hour`；等价于 `this->hour`。

---

### 8.6.3 示例：求数组最大值的 `Arraymax` 类

完整定义如下：

```cpp
#include <iostream>
using namespace std;

class Arraymax {
public:
    void setvalue();   // 对数组元素设置值
    void maxvalue();   // 求数组中的最大元素
    void showvalue();  // 输出最大值

private:
    int array[10];     // 整型数组
    int max;           // 存放最大值
};

void Arraymax::setvalue() {
    for (int i = 0; i < 10; ++i) {
        cin >> array[i];
    }
}

void Arraymax::maxvalue() {
    max = array[0];
    for (int i = 1; i < 10; ++i) {
        if (array[i] > max) {
            max = array[i];
        }
    }
}

void Arraymax::showvalue() {
    cout << "max=" << max << endl;
}

int main() {
    Arraymax a;      // 定义对象

    a.setvalue();    // 输入数组元素
    a.maxvalue();    // 求最大值
    a.showvalue();   // 输出最大值

    return 0;
}
```

分析要点：

* 将 **数组 + 相关操作（输入、求最大值、输出）** 封装在 `Arraymax` 类中。
* 外部只需要：

  * 创建对象 `Arraymax a;`
  * 按顺序调用 `a.setvalue()`、`a.maxvalue()`、`a.showvalue()` 即可。
* 内部如何存储数组、如何比较求最大值，对使用者都是透明的，体现了 **封装（数据与操作一体化）** 和 **信息隐蔽（只暴露必要接口）**。

---

## 8.7 静态库示例（头文件 + 库文件的接口/实现分离）

最后看一个关于静态库的小例子，用来展示头文件与库文件的配合方式。

### 8.7.1 头文件 `rqm.h`

```cpp
// rqm.h
#include <iostream>
using namespace std;

extern int i;   // 在其他编译单元中定义的全局变量

void f1();
int  f2();
```

### 8.7.2 库实现文件（生成 `rqm.lib`）

```cpp
// rqm.cpp
#include "rqm.h"

int i = 100;

void f1() {
    cout << "OK!" << endl;
}

int f2() {
    return i + 9;
}
```

* 把这个工程编译为静态库 `rqm.lib`；
* 将 `rqm.lib` 与 `rqm.h` 放到某个目录（例如 `C:/rqm`）备用。

### 8.7.3 在另一个工程中使用静态库

```cpp
// 测试工程 main.cpp
#include <iostream>
using namespace std;

#include "C:/rqm/rqm.h"
#pragma comment (lib, "C:/rqm/rqm.lib")   // 告诉链接器要链接此库

int main() {
    f1();              // 调用库中的函数
    cout << i  << endl;
    cout << f2() << endl;
    return 0;
}
```

要点小结：

* 通过 `#include "rqm.h"` 让编译器了解函数和变量的声明；
* 通过 `#pragma comment(lib, "...")` 或工程设置，将 `rqm.lib` 链接进最终可执行程序；
* 整体思想与类的封装类比：

  * 头文件提供“接口声明”；
  * 库文件或源文件中隐藏具体实现。

---


## 第 8 章 类和对象 —— 选择题练习（20 题）
---

### 1. 关于“对象”的概念，下列说法中**正确**的是（ ）。

A. 对象只有属性，没有行为  
B. 对象只有行为，没有属性  
C. 对象具有属性和行为，并能根据外界信息执行相应功能  
D. 对象只是一个函数的集合  

:::success[Answer]
**Q1：C。**  
书中指出，对象具有两个要素：属性和行为，并且能根据外界给出的信息执行相应的功能，这正是面向对象描述“对象”的标准表述。
:::

---

### 2. 关于“封装与信息隐蔽”的说法，以下哪一项**最符合**教材的描述（ ）。

A. 把所有成员都对外界开放，便于使用  
B. 把对象的全部成员与外界隔离，完全不能访问  
C. 可以对对象进行封装处理，把一部分属性和功能对外界屏蔽  
D. 只需封装函数，不需要封装数据  

:::success[Answer]
**Q2：C。**  
封装的要点在于“有选择地对外开放”，即可以把一部分属性和功能对外界屏蔽，实现信息隐蔽，而不是全部开放或全部隔离。
:::

---

### 3. 在 C++ 中，关于“类”和“对象”的关系，正确的是（ ）。

A. 类是具体的，占用内存；对象是抽象的，不占内存  
B. 类是对象的抽象类型，对象是类的具体实例  
C. 类和对象等价，只是名称不同  
D. 类只能有一个对象实例  

:::success[Answer]
**Q3：B。**  
教材明确指出：C++ 中对象的类型称为“类（class）”，是对象的抽象，而对象是类的具体实例（instance）。
:::

---

### 4. 关于类的一般声明形式，以下哪一项写法**最符合**教材中给出的标准形式（ ）。

A.  
```cpp
class 类名 {
    数据和函数;
};
```  

B.  
```cpp
class 类名 {
private:
    私有数据和成员函数;
public:
    公用数据和成员函数;
};
```  

C.  
```cpp
struct 类名 {
    公用数据和成员函数;
};
```  

D.  
```cpp
class 类名 {
    public:
    private:
};
```  

:::success[Answer]
**Q4：B。**  
教材给出的典型一般形式是：`class 类名 { private: …; public: …; };`，并明确解释 `private` 与 `public` 是成员访问限定符。
:::

---

### 5. 若在类体中**没有**显式写出 `private` 或 `public` 关键字，则类的成员默认是（ ）。

A. public  
B. private  
C. protected  
D. static  

:::success[Answer]
**Q5：B。**  
书中明确指出：如果类的成员既不指定 `private`，也不指定 `public`，系统默认为是**私有的（private）**。
:::

---

### 6. 关于 `class` 与 `struct` 在 C++ 中的差异，下列说法正确的是（ ）。

A. 语法上完全不同，不能互换使用  
B. `struct` 不能拥有成员函数，而 `class` 可以  
C. 若不写访问限定符，`class` 默认 `private`，`struct` 默认 `public`  
D. `struct` 在 C++ 中已经被废弃，不能再使用  

:::success[Answer]
**Q6：C。**  
教材指出：C++ 允许用 `struct` 定义一个类，如果对成员不作 `private` 或 `public` 声明，系统将其默认为 `public`；而 `class` 默认是 `private`。
:::

---

### 7. 关于对象定义的几种形式，下列语句中**不符合**教材规范、且不推荐使用的是（ ）。

A.  
```cpp
class Student { /*…*/ };
Student s1, s2;
```  

B.  
```cpp
class Student { /*…*/ } s1, s2;
```  

C.  
```cpp
class { /*…*/ } s1, s2;
```  

D.  
```cpp
Student s1, s2;
```  

:::success[Answer]
**Q7：C。**  
教材提到可以定义“无类名”的类对象：`class { … } s1, s2;`，但指出“很少用，也不提倡用”。因此这是不推荐的形式。
:::

---

### 8. 关于成员访问权限，以下说法中正确的是（ ）。

A. 在类外可以直接访问任何成员，包括 `private`  
B. 私有成员函数可以在类外直接调用  
C. 公用成员函数只能在类外调用，类内不能调用  
D. 私有成员只能被本类中的成员函数访问，类外不能直接访问  

:::success[Answer]
**Q8：D。**  
章节中指出：私有的成员函数和私有数据成员只能被本类中的其他成员函数调用和访问，不能在类外被直接调用或访问。
:::

---

### 9. 关于在类外定义成员函数的规则，下列选项中**正确**的是（ ）。

A. 在类外定义成员函数时不需要类名，直接写函数名即可  
B. 在类外定义成员函数时必须使用“类名::函数名”  
C. 在类外定义成员函数时必须将函数定义写在 `main` 函数之后  
D. 在类外定义成员函数时禁止使用作用域运算符 `::`  

:::success[Answer]
**Q9：B。**  
教材强调：成员函数在类外定义时，必须在函数名前面加上类名和作用域运算符 `::`，如 `void Student::display()`，以表明该函数属于哪个类。
:::

---

### 10. 关于 `inline` 成员函数，下列说法**错误**的是（ ）。

A. 在类体内直接定义的成员函数，可以不写 `inline` 关键字，也会被当作内置函数  
B. 类外定义的成员函数，若希望成为内置函数，需要用 `inline` 显式声明  
C. 在声明或定义中任一处写 `inline` 即可，不必两处都写  
D. 只要是成员函数，编译器都会自动将其处理为 `inline` 函数  

:::success[Answer]
**Q10：D。**  
教材说明：只有类内定义的成员函数默认视为内置（inline），类外定义的成员函数**不会自动**成为内置函数，需要显式使用 `inline`；并非所有成员函数都会自动变为内置函数。
:::

---

### 11. 关于对象所占用的存储空间，下列描述中**正确**的是（ ）。

A. 对象所占空间只与成员函数多少有关，与数据成员无关  
B. 对象所占空间既包括数据成员，又包括函数代码  
C. 对象所占空间只由数据成员决定，与成员函数代码无关  
D. 不同对象会各自拷贝一份成员函数代码  

:::success[Answer]
**Q11：C。**  
本章通过 `Time` 类与 `sizeof(Time)` 的例子说明：一个对象所占的空间大小只取决于其数据成员所占的空间，与成员函数代码无关，函数代码是所有对象共享的。
:::

---

### 12. 针对“不同的对象如何通过同一段函数代码操作各自的数据”这一问题，C++ 专门提供了哪一个隐含指针（ ）。

A. `self`  
B. `this`  
C. `super`  
D. `that`  

:::success[Answer]
**Q12：B。**  
教材指出，C++ 为此专门设立了名为 `this` 的指针，用来指向当前对象，从而使同一段成员函数代码可以作用于不同对象的数据。
:::

---

### 13. 在类外通过对象名访问成员时，以下哪一项**语法形式**是正确的（假定 `num` 为公用数据成员）（ ）。

A. `对象名 -> num`  
B. `对象名 : num`  
C. `对象名.num`  
D. `对象名::num`  

:::success[Answer]
**Q13：C。**  
访问对象中成员的一般形式为：`对象名.成员名`，即使用成员运算符 `.`；`->` 用于指向对象的指针。
:::

---

### 14. 若 `Time t, *p = &t;`，以下访问成员 `hour` 的写法中，哪一个是**不合法**的（ ）。

A. `t.hour`  
B. `(*p).hour`  
C. `p->hour`  
D. `&t.hour`  

:::success[Answer]
**Q14：D。**  
前三种写法在教材中明确指出是等价的访问：`t.hour`、`(*p).hour`、`p->hour`。`&t.hour` 取得的是地址，语义上并非“访问成员本身”的标准形式，在选择题语境下视为不符合教材给出的访问语法。
:::

---

### 15. 已有 `Time t1; Time &t2 = t1;`，关于 `t2` 的描述，哪一项最为准确（ ）。

A. `t2` 是另一个独立的 `Time` 对象  
B. `t2` 是指向 `t1` 的指针  
C. `t2` 是 `t1` 的引用（别名），`t2.hour` 等价于 `t1.hour`  
D. `t2` 只能读 `t1` 的数据，不能修改  

:::success[Answer]
**Q15：C。**  
教材示例指出：`Time &t2 = t1;` 使得 `t2` 成为 `t1` 的别名，`t2.hour` 就是 `t1.hour`，它们实际上是同一个对象。
:::

---

### 16. 关于封装性与信息隐蔽，下列说法中**正确**的是（ ）。

A. 封装的目的主要是减少代码量  
B. 用户应直接访问类的私有数据，以提高效率  
C. 公用成员函数构成对外接口，私有成员用于实现细节  
D. 若使用封装，就不能再使用头文件  

:::success[Answer]
**Q16：C。**  
本章强调：将数据和函数封装在类中，用户主要通过调用公用成员函数来实现类提供的功能，从而实现“公用接口与私有实现的分离”。
:::

---

### 17. 关于类声明和成员函数定义的组织方式，下列做法中**最符合**教材推荐的是（ ）。

A. 类声明和成员函数定义都写在 `main.cpp` 中  
B. 将类的声明写在头文件中，成员函数定义写在对应的 `.cpp` 文件中  
C. 只写 `.cpp` 文件，不需要头文件  
D. 类声明和定义分散到多个无关联文件中  

:::success[Answer]
**Q17：B。**  
教材建议：在面向对象程序开发中，一般把类的声明放在指定的头文件中（如 `student.h`），把类成员函数的定义放在一个实现文件中（如 `student.cpp`），使用该类的模块只需 `#include` 头文件。
:::

---

### 18. 在面向对象程序设计的术语中，类的成员函数通常被称为（ ），而对对象发送“调用某成员函数”的动作被称为（ ）。

A. 函数；命令  
B. 方法（method）；消息（message）  
C. 操作符；表达式  
D. 过程；指令  

:::success[Answer]
**Q18：B。**  
教材在 8.5.3 小节中指出：类的成员函数在面向对象理论中称为“方法（method）”，所谓“消息”本质上就是一个成员函数调用命令。
:::

---

### 19. 对于下列 `Time` 类定义：  
```cpp
class Time {
public:
    int hour; int minute; int sec;
    void set() { cin >> hour >> minute >> sec; }
};
```
若执行 `cout << sizeof(Time) << endl;`，下列哪一项是教材给出的说明（ ）。

A. 输出值取决于编译器，与成员个数无关  
B. 输出结果只包含成员函数 `set` 的大小  
C. 输出结果只由三个 `int` 数据成员占用的空间决定  
D. 输出结果包含三个 `int` 和函数代码两部分大小之和  

:::success[Answer]
**Q19：C。**  
教材示例中给出 `sizeof(Time)` 的值为 12，并据此说明：对象所占的空间只取决于该对象中**数据成员所占的空间**，而与成员函数无关。
:::

---

### 20. 关于运算符 `::` 与 `.` 的区别，下列叙述中**正确**的是（ ）。

A. `::` 是成员运算符，`. ` 是作用域运算符  
B. `::` 用于表明函数或成员属于哪个类或命名空间，`.` 用于访问对象中的成员  
C. 两者可以互换使用，没有语义差别  
D. `::` 只能用于全局函数，不能用于成员函数  

:::success[Answer]
**Q20：B。**  
本章特别提醒要区分作用域运算符 `::` 和成员运算符 `.`：前者用于指明函数（或静态成员等）属于哪个类（或命名空间），后者用于通过对象访问其成员。
:::
