## 12.1 多态性的概念

### 1. 多态性的基本定义

**多态性（polymorphism）**：
向不同的对象发送**同一个消息**（即同名成员函数调用），不同对象在接收时会产生**不同的行为（不同实现）**。

一句话概括：**一个接口，多种方法**。

### 2. 多态性的两大类别

1. **静态多态性（编译时多态）**

   * 在**编译阶段**就能确定调用的是哪一个函数。
   * 典型形式：

     * **函数重载**（同名不同参数）
     * **运算符重载**
   * 其本质是：编译器根据参数类型和个数，在编译期选定具体函数入口地址。

2. **动态多态性（运行时多态）**

   * 在**程序运行过程中**才动态确定“究竟调用哪一个函数”。
   * 典型形式：

     * 通过**虚函数（virtual function）** + **基类指针或引用**实现。
   * 本质是：运行时根据对象的真实类型，在**虚函数表**中查找相应函数地址，再进行调用。

---

## 12.2 多态性与虚函数的关系

### 1. 虚函数的作用

在第 3 页文字中指出：

> 虚函数的作用，是允许**通过基类指针或引用访问派生类中的重载函数**。

换句话说：

* 基类中先声明某个函数为 `virtual`；
* 派生类中**重写（覆盖）**该函数；
* 当我们用“**基类类型的指针/引用**”指向派生类对象，并通过它调用该虚函数时：

  * 调用的将是**派生类版本**，而不是基类版本。
* 这就是“一个接口（基类虚函数），多种方法（各个派生类的覆盖实现）”。

### 2. “一类族，多种实现”

在同一“类族”中（某个基类及其派生类们）：

* 所有类对象都提供同名虚函数作为统一接口；
* 每个类根据自身语义，实现各自版本；
* 利用“基类指针/引用 + 虚函数调用”时，系统自动根据对象的真实类型选择正确版本。

---

## 12.3 虚函数

### 12.3.1 虚函数的基本使用与示例

#### 1. 典型示例：Student / Graduate（第 4 页）

```cpp
class Student {
public:
    Student(int n, string nam) { num = n; name = nam; }

    // 声明为虚函数
    virtual void display() {
        cout << "num:"  << num
             << " name:" << name << "\n";
    }
protected:
    int    num;
    string name;
};

class Graduate : public Student {
public:
    Graduate(int n, string nam, float p)
        : Student(n, nam), pay(p) {}

    // 覆盖基类虚函数
    void display() {
        cout << "num:"  << num
             << " name:" << name
             << " pay="  << pay << endl;
    }
private:
    float pay;
};

int main() {
    Graduate grad1(2001, "Wang", 1200);
    Student *pt = &grad1;   // 基类指针指向派生类对象
    pt->display();          // 调用 Graduate::display()
}
```

关键观察：

* 基类 `Student::display` 被声明为 `virtual`。
* 派生类 `Graduate` 覆盖了 `display`。
* `Student *pt = &grad1;` —— 典型**向上转型**（up-cast）：

  * 指针类型是 `Student*`，实际指向 `Graduate` 对象。
* `pt->display();` 调用的不是 `Student::display`，而是 `Graduate::display`。
  —— 这就是运行时多态。

> 没有 `virtual` 时，同样的代码会调用基类版本，只表现为“静态绑定”，不具备多态性。

---

### 12.3.2 虚函数的声明与覆盖规则（第 5–6 页）

#### 1. 使用步骤总结

使用虚函数，一般要满足以下步骤：

1. **在基类中，用 `virtual` 声明成员函数为虚函数。**

   ```cpp
   class Base {
   public:
       virtual void f(int x);
   };
   ```

   * 在**类外定义**该成员函数时，**不能再写 `virtual`**：

   ```cpp
   void Base::f(int x) {
       // ...
   }
   ```

2. **在派生类中“重新定义（覆盖）”此虚函数。**

   要求：

   * 函数名相同；
   * 返回类型相同（或协变返回类型，教材一般要求相同）；
   * 参数个数和参数类型完全一致。

   ```cpp
   class Derived : public Base {
   public:
       void f(int x) override { /* 新实现 */ }
   };
   ```

   在教材语境中，“覆盖”就是典型的**重写虚函数**。

3. **定义一个基类指针或引用，使其指向派生类对象。**

   ```cpp
   Derived d;
   Base* pb = &d;     // 向上转型
   Base& rb = d;      // 基类引用绑定到派生类对象
   ```

4. **通过该基类指针或引用调用虚函数。**

   ```cpp
   pb->f(10);   // 动态绑定，根据对象实际类型调用 Derived::f
   rb.f(10);    // 同样调用 Derived::f
   ```

   这时才真正体现“动态多态性”。

#### 2. 若基类函数不是 `virtual` 会怎样？（第 6 页说明）

教材特别说明：

* 如果基类中的**非虚函数**在派生类中被重新定义（同名同参）：

  * 用 **基类指针** 指向派生类对象，并通过它调用该函数时：

    * 调用的仍是**基类版本**（静态绑定）。
  * 用 **派生类指针** 调用，则调用的是**派生类版本**。

* 这只是“同名函数隐藏”的现象，并**不是多态性**。

示意代码：

```cpp
class Base {
public:
    void f() { cout << "Base::f\n"; }   // 非虚函数
};

class Derived : public Base {
public:
    void f() { cout << "Derived::f\n"; }  // 同名隐藏
};

Derived d;
Base* pb = &d;
Derived* pd = &d;

pb->f();   // 输出 Base::f（静态绑定）
pd->f();   // 输出 Derived::f
```

只有当 `Base::f` 被声明为 `virtual` 时，`pb->f()` 才会根据对象真实类型调用 `Derived::f`。

---

### 12.3.3 静态关联与动态关联（第 7 页）

* **静态关联（static binding / early binding）**

  * 在**编译时**就已经确定函数调用与哪个类的函数体相连。
  * 例如：普通函数、非虚成员函数、重载函数调用等。
  * 编译器在生成目标代码时，已经把调用指令的目标地址固定下来。

* **动态关联（dynamic binding / late binding）**

  * 通过基类指针/引用调用**虚函数**时，系统在**运行阶段**才把调用和某个具体类的函数实现“绑定”在一起。
  * 具体过程依赖于虚函数表（vtable）：运行时根据对象中保存的“虚表指针”查表得出函数地址。

总结：

> 使用虚函数 + 基类指针/引用，可以把函数调用的“绑定时机”从编译期推迟到运行期，从而实现动态多态。

---

### 12.3.4 何时应当声明虚函数 & 一些限制（第 8 页）

使用虚函数时，应注意以下原则和限制：

1. **只有类的成员函数才能被声明为虚函数**

   * **普通函数**（类外的自由函数）不能声明为虚函数。
   * 原因：虚函数是一种“通过对象或类指针进行调用时的动态绑定机制”，只在类内部有意义。

2. **静态成员函数不能是虚函数**

   * 静态成员函数不依赖对象实例（没有 `this` 指针），自然不可能基于“对象类型”做动态分派。
   * 因此不能同时既是 `static` 又是 `virtual`。

3. **内联函数不能是“实际上的”虚函数**

   * 教材给出的说法是“内联函数不能是虚函数”，侧重点是：

     * 虚函数要通过虚表在运行时做动态查找；
     * 真正的内联则要求在编译期就把函数体展开；
     * 二者目标相反。
   * 从语言标准看，可以在类中把虚函数“写成内联形式”，但一旦通过基类指针/引用进行动态绑定，编译器一般不会做真正的内联展开，这里按教材口径理解即可。

4. **希望产生动态多态效果的继承关系通常应为公有继承**

   * 常见模式：`class Derived : public Base`。
   * 只有公有继承才构成“is-a” 关系，基类指针/引用才能自然地指向派生类对象，供外部使用。

5. **空间与时间开销**

   * 一旦类中出现虚函数，编译器通常会为该类构造一张**虚函数表（virtual function table，vtable）**：

     * 存放各个虚函数在当前类版本中的**入口地址**；
     * 每个对象中会额外存放一个指向该表的隐藏指针。
   * 因此：

     * 每个对象存储空间略有增加（多出一个指针）；
     * 每次虚函数调用需要一次间接寻址（查表），在时间上比普通函数调用稍慢。
   * 不过，从工程实践看，这种开销相对很小，换来的灵活性往往更重要。

---

### 12.3.5 虚析构函数（第 9–10 页）

#### 1. 问题场景

看第 9–10 页的例子：

```cpp
class Point {           // 基类
public:
    Point() {}
    ~Point() {          // 析构函数不是虚函数
        cout << "executing Point destructor" << endl;
    }
};

class Circle : public Point { // 派生类
public:
    Circle() {}
    ~Circle() {
        cout << "executing Circle destructor" << endl;
    }
};
```

在 `main` 中：

```cpp
int main() {
    Point* p = new Circle;  // 用 new 建立临时的 Circle 对象
    delete p;               // 用基类指针释放
    return 0;
}
```

运行结果只有：

```text
executing Point destructor
```

也就是说：

* 只调用了 `Point` 的析构函数；
* **没有调用** `Circle` 的析构函数。

如果 `Circle` 中申请了堆空间或持有某些资源，就会造成资源泄漏。

#### 2. 解决办法：把基类析构函数声明为虚函数

修改基类：

```cpp
class Point {
public:
    Point() {}

    // 声明虚析构函数
    virtual ~Point() {
        cout << "executing Point destructor" << endl;
    }
};

class Circle : public Point {
public:
    Circle() {}

    ~Circle() {
        cout << "executing Circle destructor" << endl;
    }
};
```

再次执行：

```cpp
Point* p = new Circle;
delete p;
```

输出顺序将变为：

```text
executing Circle destructor
executing Point destructor
```

即：

1. 先调用派生类 `Circle` 的析构函数；
2. 再调用基类 `Point` 的析构函数。

这和对象栈上销毁时“先子后父”的顺序一致。

> 一旦基类析构函数被声明为虚函数，其所有派生类的析构函数也**自动成为虚函数**。

#### 3. 结论

* **对于打算通过基类指针删除对象的类层次，基类析构函数几乎总是应该声明为 `virtual`。**
* 反之，如果通过基类指针 `delete` 的情况永远不会发生，可以不必设为虚析构，但在现代 C++ 设计中通常以“安全”为先。

---

### 12.3.6 构造函数不能是虚函数（第 11 页）

教材给出的理由可以概括为：

* 在执行构造函数时，对象还**没有完全建立**；
* 虚函数的动态绑定依赖于“对象中指向虚函数表的指针已经就位”；
* 因此，从语义和实现上都不适合把构造函数设计成虚函数。

另一角度理解：

* 虚函数的分派是“**已知对象类型但不确定具体层级实现**”时的运行期选择；
* 而构造过程恰恰是在“**确定对象是哪个具体类型**”时执行的，调用哪个构造函数在编译期就已决定。

所以：

> **构造函数不能被声明为虚函数。**

---

## 12.4 纯虚函数与抽象类

### 12.4.1 纯虚函数（第 12 页）

#### 1. 定义与语法

有时在基类中希望：

* 只提供一个“**函数名 + 接口形式**”，表明子类**必须实现这个函数**；
* 但在基类中**不写具体实现**。

这时可以把该函数声明为**纯虚函数（pure virtual function）**，语法形式：

```cpp
virtual 返回类型 函数名(参数表) = 0;
```

要点：

1. 纯虚函数**没有函数体**（不能写 `{...}`）。
2. 末尾的 `= 0` 只是一个标记，告诉编译器“这是纯虚函数”，并不表示数值意义上的 0。
3. 这条语句是一个**声明语句**，末尾要有分号。
4. 纯虚函数只有名字和接口形式，**不能直接被调用**。

如果某个类中声明了纯虚函数，而它的派生类**没有对该函数给出定义**，那么这个函数在派生类中仍然是纯虚函数。

---

### 12.4.2 抽象类（第 13 页）

#### 1. 抽象类的定义

> **凡是包含至少一个纯虚函数的类，都是抽象类（abstract class）。**

特点：

* 由于含有不能被直接调用的纯虚函数，这样的类**不能建立对象**。
* 抽象类的作用是作为“**接口类 / 抽象基类**”，用于被继承和被覆写。

#### 2. 派生类对抽象类的继承

* 如果抽象类的派生类对基类所有纯虚函数都给出了具体定义，则这个派生类就**不再是抽象类**，可以用来定义对象：

  ```cpp
  class Base {
  public:
      virtual void f() = 0;
  };

  class Derived : public Base {
  public:
      void f() { cout << "Derived::f" << endl; }
  };

  Derived d;   // 合法
  ```

* 如果派生类没有对所有纯虚函数给出定义，则该派生类仍然是抽象类，仍然不能用来定义对象。

#### 3. 抽象类的指针与引用

虽然抽象类**不能定义对象**，但可以：

* 定义**指向抽象类的指针**；
* 定义**抽象类的引用**。

这些指针或引用可以指向其具体派生类的对象，并通过虚函数调用实现多态性。例如：

```cpp
Base* pb;          // Base 是抽象类
Derived d;
pb = &d;
pb->f();           // 动态绑定，调用 Derived::f
```

---

### 12.4.3 应用实例：Animal / Dog / Cat / Cow（第 14–15 页）

#### 1. 类层次结构

第 14 页给出了一个简洁的例子：

```cpp
class Animal {
public:
    virtual void Sound() = 0;  // 纯虚函数
};

class Dog : public Animal {
public:
    virtual void Sound() {
        cout << "汪！" << endl;
    }
};

class Cat : public Animal {
public:
    virtual void Sound() {
        cout << "喵！" << endl;
    }
};

class Cow : public Animal {
public:
    virtual void Sound() {
        cout << "哞！" << endl;
    }
};
```

说明：

* `Animal` 中的 `Sound()` 是纯虚函数，因此 `Animal` 是抽象类；
* `Dog`, `Cat`, `Cow` 都实现了 `Sound()`，因此它们不是抽象类，可以创建对象。

#### 2. 利用基类指针和引用实现多态（第 15 页）

```cpp
void sound1(Animal* p) {
    p->Sound();
}

void sound2(Animal& a) {
    a.Sound();
}

int main() {
    Dog dog;
    Cat cat;
    Cow cow;

    sound1(&dog);
    sound1(&cat);
    sound1(&cow);

    sound2(dog);
    sound2(cat);
    sound2(cow);
}
```

分析：

* `sound1` 的形参类型是 `Animal*`，`sound2` 的形参类型是 `Animal&`；
* 在 `main` 中分别把 `Dog`、`Cat`、`Cow` 对象的地址或引用传入；
* 每一次 `Sound()` 调用，都会根据实参对象的真实类型调用对应版本：

  * `dog` → `Dog::Sound()` 输出“汪！”
  * `cat` → `Cat::Sound()` 输出“喵！”
  * `cow` → `Cow::Sound()` 输出“哞！”

这正是“一个接口 `Sound()`，多种方法（不同动物的叫声）”的直观演示。

---

## 本章知识结构小结

1. **多态性的概念**

   * 静态多态：函数重载、运算符重载等，编译期完成绑定。
   * 动态多态：依赖虚函数，通过基类指针/引用在运行时选择具体实现。

2. **虚函数的机制**

   * 基类用 `virtual` 声明成员函数；
   * 派生类通过同名、同参函数进行覆盖；
   * 利用基类指针或引用指向派生类对象，并通过它调用虚函数；
   * 编译器为含虚函数的类建立虚函数表（vtable），通过对象中的虚表指针在运行时查表实现动态绑定。

3. **静态关联与动态关联**

   * 静态关联：调用目标在编译阶段就确定。
   * 动态关联：通过虚函数在运行阶段再确定调用的具体函数。

4. **虚函数的使用规则与限制**

   * 只能修饰成员函数；
   * 静态成员函数不能为虚函数；
   * 内联函数与虚函数在实现机制上存在矛盾，通常不将真正需要动态绑定的函数作为内联；
   * 通常配合**公有继承**使用，形成“is-a” 关系；
   * 使用虚函数会带来额外空间（虚表指针）和时间（查表）开销，但换来接口的灵活性。

5. **虚析构函数与资源安全**

   * 若基类指针被用来 `delete` 派生类对象，则基类析构函数应声明为 `virtual`；
   * 否则只会执行基类析构函数，派生类析构函数不被调用，可能导致资源泄漏；
   * 一旦基类析构函数是虚函数，其所有派生类析构函数也自动成为虚的。

6. **构造函数不能是虚函数**

   * 构造期间对象尚未完全建立，虚函数分派机制尚不可用；
   * 构造函数的调用在编译时就已经静态确定。

7. **纯虚函数与抽象类**

   * 纯虚函数语法：`virtual 返回类型 函数名(参数表) = 0;`
   * 含有纯虚函数的类为抽象类，不能建立对象；
   * 派生类只有在实现了全部纯虚函数后，才不再是抽象类，可以创建对象；
   * 抽象类本身仍可通过指针或引用作为“统一接口类型”，用来指向具体派生类对象并进行多态调用。

8. **典型应用模式**

   * 定义抽象基类（如例中的 `Animal`）提供统一接口（如 `Sound()`）；
   * 各个派生类实现各自版本；
   * 编写操作基类指针/引用的算法（如 `sound1`, `sound2`），而在运行时根据实参对象类型表现出不同行为。


