
## C++ 面向对象期末复习总纲

> 建议：通读一遍后，自己在纸上把关键概念写一次，再手敲两段有继承和多态的代码，加深记忆。

---

## 一、类和对象（Class & Object）

### 1. 类与对象的概念

- **类（class）**：对一类对象的抽象描述，是一种 **自定义类型**。
  - 描述“有什么数据”（**成员变量 / 数据成员**）
  - 描述“能做什么操作”（**成员函数 / 方法**）
- **对象（object）**：类的具体实例，占用内存，有具体的数据值。

```cpp
class Point {
private:
    int x;   // 成员变量
    int y;
public:
    void set(int xVal, int yVal) { // 成员函数
        x = xVal;
        y = yVal;
    }
    void print() {
        cout << "(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Point p;       // p 是对象
    p.set(3, 4);   // 通过对象调用成员函数
    p.print();
}
```

### 2. 面向对象的三个（四个）基本特性

1. **封装（Encapsulation）**
   - 把数据和操作封装在类中，通过 **访问控制符** 限制外界访问。
   - 优点：隐藏实现细节，提高安全性与可维护性。

2. **继承（Inheritance）**
   - 新类在已有类的基础上扩展。
   - 基类（父类） → 派生类（子类）。
   - “**is-a**” 关系：Student is a Person。

3. **多态（Polymorphism）**
   - 同一接口，不同实现。
   - 编译时多态：函数重载、运算符重载。
   - 运行时多态：虚函数 + 基类指针/引用。

4. **抽象（Abstraction）**
   - 只保留关键特征，忽略不必要的细节。
   - 在 C++ 中体现：抽象类、纯虚函数。

---

## 二、访问权限（public / private / protected）

### 1. 三种访问控制符

```cpp
class Test {
public:     // 公有成员：类外可以访问
    int a;
protected:  // 保护成员：类外不可访问，子类可以访问
    int b;
private:    // 私有成员：类外不可访问，子类也不能直接访问
    int c;
};
```

- **public**：
  - 任何地方（同一程序中，只要有对象）都可以通过对象访问。
- **protected**：
  - **类外** 不能访问；
  - **派生类内部** 可以访问（看成“给子类用的 private”）。
- **private**：
  - 只能在本类的成员函数、友元中访问，子类也不能直接访问。

> 默认访问权限：  
> - `class` 中默认是 `private`  
> - `struct` 中默认是 `public`

### 2. 使用访问控制实现封装

常见写法：数据私有 + 公有接口。

```cpp
class Account {
private:
    string name;
    double balance;
public:
    Account(string n, double b) : name(n), balance(b) {}
    void deposit(double amt) { balance += amt; }
    void show() const {
        cout << name << ": " << balance << endl;
    }
};
```

---

## 三、指针与 const（常量指针 / 指向常量的指针）

**核心口诀：`const` 修饰谁，谁就不能被改。**

### 1. 指向常量的指针（pointer to const）

```cpp
const int *p;   // 或者 int const *p;
```

- 含义：**通过 p 不能修改它指向的对象**。
- `p` 本身可以变，可以指向别的地址。

```cpp
int a = 10, b = 20;
const int *p = &a;   // OK
//*p = 30;           // 错误：不能通过 p 改 a
p = &b;              // OK：p 可以指向别处
```

### 2. 常指针（const pointer）

```cpp
int * const p = &a;
```

- 含义：**p 本身不能变**，一旦初始化后就不能指向别的对象。
- 但可以通过 p 修改指向的对象的值。

```cpp
int a = 10, b = 20;
int * const p = &a;
//p = &b;           // 错误：p 不能改指向
*p = 30;            // OK：通过 p 改 a 的值
```

### 3. 指向常量的常指针

```cpp
const int * const p = &a;
```

- p 不能变指向，对象也不能通过 p 被修改。

### 4. 小结表格（便于选择题）

| 声明写法               | p 能否改指向 | 能否通过 p 改数据 |
|------------------------|-------------|--------------------|
| `int *p`               | ✅          | ✅                 |
| `const int *p`         | ✅          | ❌                 |
| `int * const p`        | ❌          | ✅                 |
| `const int * const p`  | ❌          | ❌                 |

---

## 四、构造函数（Constructor）

### 1. 构造函数的概念与语法

- 函数名与类名相同。
- **没有返回类型**（连 `void` 也不能写）。
- 在创建对象时由系统自动调用。

```cpp
class A {
public:
    A() { cout << "默认构造" << endl; }
    A(int x) { cout << "带参构造: " << x << endl; }
};
```

### 2. 构造函数的性质（判断题高频）

1. 可以 **重载**（参数不同）。
2. 可以有 **默认参数**。
3. 不能有返回值类型，也不能写 `return` 返回一个值。
4. 如果程序员 **不写任何构造函数**，编译器会自动生成一个 **默认构造函数**（无参，什么都不做的那种“空实现”）。
5. 一旦自己写了任何构造函数，编译器 **不再自动生成** 默认构造。
6. 构造函数可以是 `public` / `protected` / `private`，若为 `private`，则无法在类外直接构造对象（常用于单例模式等）。

### 3. 构造函数的类别

1. **默认构造函数**：无参，或所有参数都有默认值。
   ```cpp
   A() {}            // 默认构造
   A(int x = 0) {}   // 这也是默认构造
   ```

2. **带参构造函数**：用于初始化成员。
3. **拷贝构造函数**：
   ```cpp
   A(const A &other);
   ```
   - 在下面情况会被调用：
     - 用一个已存在对象初始化新对象：`A b(a);`
     - 函数参数按值传递：`void foo(A x);` 调用 `foo(a);`
     - 函数按值返回对象。

4. （了解）**委托构造函数**：C++11
   ```cpp
   A() : A(0) {}  // 在一个构造函数中调用另一个构造函数
   ```

### 4. 初始化列表（constructor initializer list）

- 常用写法：

```cpp
class B {
private:
    int x;
    const int y;
public:
    B(int a, int b) : x(a), y(b) {  // 初始化列表
        // 构造函数体
    }
};
```

- 必须在 **初始化列表** 中初始化的成员：
  1. `const` 成员
  2. 引用成员 `T&`
  3. 成员对象（调用其构造函数）

### 5. 构造顺序（重要）

创建派生类对象时：

1. **基类构造函数** 先执行。
2. 再按声明顺序构造 **成员对象**。
3. 最后执行 **派生类自身的构造函数体**。

析构顺序与之相反：**派生类析构 → 成员对象析构 → 基类析构**。

---

## 五、继承（Inheritance）与继承方式的访问权限变化

### 1. 继承的基本语法

```cpp
class Base {
public:
    int a;
protected:
    int b;
private:
    int c;
};

class Derived : public Base {    // public / protected / private 继承
public:
    void func() {
        a = 1;   // OK（基类 public）
        b = 2;   // OK（基类 protected，子类可访问）
        //c = 3; // 错误：基类 private 子类不可访问
    }
};
```

### 2. 三种继承方式

```cpp
class D1 : public Base {};
class D2 : protected Base {};
class D3 : private Base {};
```

**关键问题：基类成员在派生类 *中的访问级别* 如何变化？**

- 先记住一个原则：  
  **private 无论怎样继承，永远是子类不可见的。**

- 下面这张表需要熟悉（常见选择/填空）：

| 基类成员在基类中 | 继承方式      | 在派生类中的“对外可见性” | 派生类内部能否访问 |
|------------------|---------------|---------------------------|--------------------|
| public           | public 继承   | public                    | ✅                  |
| protected        | public 继承   | protected                 | ✅                  |
| private          | 任意继承      | 不可见                    | ❌                  |
| public           | protected 继承| protected                 | ✅                  |
| protected        | protected 继承| protected                 | ✅                  |
| public           | private 继承  | private                   | ✅（类内）          |
| protected        | private 继承  | private                   | ✅（类内）          |

另外：

- **外部通过对象/对象指针访问时，取决于“在派生类中的对外级别”。**
- 一般实际开发中最常见的是 **public 继承**。

### 3. 继承的特性总结（考试反复考）

1. 派生类 **拥有基类的所有成员**（包括 private），只是访问权限不同；只是 private 在派生类内部访问不到。
2. 构造顺序：先基类后派生；析构顺序反过来。
3. 派生类可以新增自己的数据成员、成员函数。
4. 允许多层继承：`class B : public A {}; class C : public B {};`。
5. 允许多重继承：`class C : public A, public B {};`（考试一般不会太深考细节）。

---

## 六、多态（Polymorphism）、虚函数与抽象类

### 1. 静态多态 vs 动态多态

- **静态多态**（编译时）：函数重载、运算符重载。编译时决定调用哪个函数。
- **动态多态**（运行时）：通过虚函数实现，运行时看“指针/引用实际指向对象的类型”。

### 2. 动态多态的三个必要条件

1. 存在 **继承** 关系（基类 & 派生类）。
2. 基类中有 **虚函数**，用 `virtual` 关键字声明。
3. 通过 **基类指针或引用** 指向派生类对象，并调用虚函数。

```cpp
class Base {
public:
    virtual void show() { cout << "Base" << endl; }
};

class Derived : public Base {
public:
    void show() override { cout << "Derived" << endl; }
};

int main() {
    Base b;
    Derived d;
    Base *p = &d;   // 基类指针指向派生类对象
    p->show();      // 调用的是 Derived::show() —— 运行时多态
}
```

### 3. 虚函数（virtual function）

- 在基类中前面加 `virtual`。
- 派生类 **重写（override）** 时，函数原型必须一致（返回类型、函数名、参数列表完全相同）。
- C++11 中可以在派生类重写函数后加 `override` 关键字，方便编译器检查。

```cpp
class Base {
public:
    virtual void f(int x);
};

class Derived : public Base {
public:
    void f(int x) override;  // 推荐写法
};
```

### 4. 纯虚函数与抽象类

```cpp
class Shape {
public:
    virtual double area() const = 0;  // 纯虚函数
};
```

- 含有 **至少一个纯虚函数** 的类称为 **抽象类**。
- 抽象类 **不能直接定义对象**：`Shape s; // 错误`
- 但可以定义指针或引用：`Shape *p;`，用来指向派生类对象。
- 抽象类作为“接口”或“公共基类”。

### 5. 多态的典型使用示例

```cpp
class Shape {
public:
    virtual double area() const = 0;
    virtual ~Shape() {}   // 虚析构函数，见后文
};

class Circle : public Shape {
private:
    double r;
public:
    Circle(double r) : r(r) {}
    double area() const override { return 3.14 * r * r; }
};

class Rectangle : public Shape {
private:
    double w, h;
public:
    Rectangle(double w, double h) : w(w), h(h) {}
    double area() const override { return w * h; }
};

int main() {
    Shape *p1 = new Circle(2.0);
    Shape *p2 = new Rectangle(3.0, 4.0);
    cout << p1->area() << endl;  // 调 Circle::area
    cout << p2->area() << endl;  // 调 Rectangle::area
    delete p1;
    delete p2;
}
```

---

## 七、运算符重载（Operator Overloading）

### 1. 基本概念

- 给已有运算符赋予“对自定义类型”的新含义。
- **不能创造新的运算符符号**，只能重定义已有的。
- 重载后应尽量保持原有的直观语义。

### 2. 语法形式

有两种形式：成员函数和普通函数（常配合 `friend`）。

#### （1）成员函数形式

```cpp
class Complex {
private:
    double r, i;
public:
    Complex(double r = 0, double i = 0) : r(r), i(i) {}

    // c3 = c1 + c2;
    Complex operator+(const Complex &rhs) const {
        return Complex(r + rhs.r, i + rhs.i);
    }
};
```

- 实际调用形式：`c1.operator+(c2);`

#### （2）普通函数 / 友元形式

常用于左操作数不是该类对象时，如 `cout << obj`。

```cpp
class Complex {
private:
    double r, i;
public:
    Complex(double r = 0, double i = 0) : r(r), i(i) {}

    friend ostream& operator<<(ostream &os, const Complex &c) {
        os << c.r << "+" << c.i << "i";
        return os;
    }
};
```

- 实际调用形式：`operator<<(cout, c);`

### 3. 不能被重载的运算符（选择题爱考）

- `.` 成员访问运算符
- `.*` 成员指针运算符
- `::` 作用域运算符
- `?:` 条件运算符
- `sizeof`

### 4. 必须是成员函数的运算符

- 赋值运算符 `operator=`
- 下标运算符 `operator[]`
- 函数调用运算符 `operator()`
- 指针访问运算符 `operator->`

### 5. 运算符重载的注意事项（判断题）

1. 不能改变运算符的 **优先级** 和 **结合性**。
2. 不能改变运算符的 **操作数个数**。
3. 不要滥用重载，否则代码可读性变差。
4. 应保持行为直观，例如自增 `++` 应让值加一。

---

## 八、静态成员（static data / static member function）

### 1. 静态数据成员

```cpp
class A {
public:
    static int count;  // 声明
};

int A::count = 0;      // 在类外定义 & 初始化（必须有这一句）
```

性质：

1. **所有对象共享一份** 数据。
2. 在程序开始时分配内存，程序结束时销毁，类似“全局变量”的生命周期。
3. 可以通过 **类名** 访问：`A::count`。
4. 数据成员本身仍然受 `public / private / protected` 限制。

典型用途：

- 统计某类对象的数量：

```cpp
class A {
public:
    static int count;
    A() { ++count; }
    ~A() { --count; }
};
int A::count = 0;
```

### 2. 静态成员函数

```cpp
class A {
private:
    static int count;
public:
    static int getCount() { return count; }
};
```

性质：

1. 没有 `this` 指针：不能访问非静态成员（因为非静态成员属于具体对象）。
2. 可以通过类名调用：`A::getCount();`
3. 可以访问静态数据成员、调用静态成员函数。

---

## 九、析构函数与虚析构函数

### 1. 析构函数的概念

```cpp
class A {
public:
    ~A() { cout << "析构" << endl; }
};
```

- 名字为 `~类名`。
- 没有参数，没有返回值。
- 对象生命周期结束时自动调用：
  - 局部对象：离开作用域时
  - 动态对象：`delete` 时
  - 全局/静态对象：程序结束时

### 2. 析构顺序

- 创建派生类对象时：
  - 构造：**基类 → 成员对象 → 派生类自身**
  - 析构：**派生类自身 → 成员对象 → 基类**
- 对象数组析构时：按下标 **逆序** 析构。

### 3. 虚析构函数（virtual destructor）

在有 **多态** 的基类中，析构函数几乎一定要写成虚函数：

```cpp
class Base {
public:
    virtual ~Base() { cout << "Base dtor" << endl; }
};

class Derived : public Base {
public:
    ~Derived() override { cout << "Derived dtor" << endl; }
};

int main() {
    Base *p = new Derived;
    delete p;  // 调用 Derived::~Derived，然后 Base::~Base
}
```

- 如果 **基类析构函数不是 virtual**：

```cpp
class Base {
public:
    ~Base() { cout << "Base dtor" << endl; }
};
class Derived : public Base {
public:
    ~Derived() { cout << "Derived dtor" << endl; }
};

int main() {
    Base *p = new Derived;
    delete p;   // 只调用 Base::~Base，Derived 部分资源无法正确释放
}
```

- 结果：可能发生 **内存泄漏** 或资源没有释放完全。

因此：

> 只要这个类打算作为 **多态基类** 使用，就应当把析构函数声明为 `virtual`。

---

## 十、friend（友元）关键字

### 1. 友元函数

```cpp
class A {
private:
    int x;
public:
    A(int x) : x(x) {}
    friend void print(const A &a);  // 友元函数声明
};

void print(const A &a) {  // 不是成员函数
    cout << a.x << endl;  // 可以访问 private 成员
}
```

性质：

1. 友元函数 **不是类的成员函数**，但可以访问类的 private/protected 成员。
2. 在类中用 `friend` 声明，只是“授予访问权限”。
3. 友元关系 **不能继承**，子类不会自动把某函数也当友元。
4. 友元破坏封装性，应有限度使用。

### 2. 友元类

```cpp
class B;

class A {
    friend class B;   // 把 B 声明为 A 的友元类
private:
    int x;
};

class B {
public:
    void f(A &a) {
        a.x = 100;    // B 可以访问 A 的 private 成员
    }
};
```

---

## 十一、常见填空点：访问控制、继承语法、静态、虚函数等

### 1. 访问控制符

- 三个：`private`、`protected`、`public`。  
- `class` 默认 `private`，`struct` 默认 `public`。

### 2. 继承相关语法

```cpp
class 派生类名 : public 基类名 {
    // ...
};
```

- 关键词：`class`、`public`、`protected`、`private`、`virtual`。

### 3. 运算符重载语法

```cpp
返回类型 operator符号(参数列表);
```

例如：

```cpp
Complex operator+(const Complex &rhs) const;
friend ostream& operator<<(ostream &, const Complex &);
```

### 4. 多态 / 虚函数 / 纯虚函数

- 声明虚函数：`virtual 返回类型 函数名(形参);`
- 声明纯虚函数：`virtual 返回类型 函数名(形参) = 0;`
- 含有纯虚函数的类是 **抽象类**。

---

## 十二、C 语言基础回顾（可能出简单填空 / 判断）

1. **main 函数头**：`int main()` 或 `int main(int argc, char *argv[])`。
2. 基本语句：
   - 顺序、选择（`if` / `switch`）、循环（`for` / `while` / `do while`）。
3. 数组与指针：
   - 一维数组 `int a[10];`
   - 字符串 `char s[100];`，`scanf` / `printf`。
4. 结构体：

```c
struct Student {
    char name[20];
    int age;
    double score;
};
```

5. 函数：值传递、形参与实参。
6. 作用域与生存期：局部变量、全局变量、`static` 局部变量。

---

## 十三、对象数组与构造 / 析构

### 1. 对象数组定义

```cpp
class A {
public:
    A() { cout << "构造" << endl; }
};

int main() {
    A arr[3];  // 调用三次默认构造函数
}
```

- 如果类没有默认构造函数：

```cpp
class A {
public:
    A(int x) {}
};

int main() {
    // A arr[3];   // 错误：需要默认构造函数
    A arr[3] = { A(1), A(2), A(3) }; // 正确
}
```

### 2. 构造 / 析构顺序

- 数组构造：按下标从小到大。
- 数组析构：按下标从大到小。

---

## 十四、典型“写运行结果”题中与继承相关的细节

### 1. 构造 / 析构顺序输出

```cpp
class Base {
public:
    Base() { cout << "B"; }
    ~Base() { cout << "b"; }
};

class Derived : public Base {
public:
    Derived() { cout << "D"; }
    ~Derived() { cout << "d"; }
};

int main() {
    Derived obj;
    return 0;
}
```

执行顺序：

- 创建 `obj`：先调用 `Base()` 输出 `B`，再调用 `Derived()` 输出 `D`。
- main 结束，`obj` 析构：先调用 `~Derived()` 输出 `d`，再调用 `~Base()` 输出 `b`。

输出结果：`BDdb`（只有一行）。

### 2. 同名成员的隐藏（名字遮蔽）

```cpp
class Base {
public:
    int x;
    void f() { cout << "Base::f" << endl; }
};

class Derived : public Base {
public:
    int x;  // 隐藏了 Base::x
    void f() { cout << "Derived::f" << endl; } // 隐藏了 Base::f
};

int main() {
    Derived d;
    d.x = 1;       // 访问的是 Derived::x
    d.Base::x = 2; // 强制访问 Base::x
    d.f();         // 调用 Derived::f
    d.Base::f();   // 强制调用 Base::f
}
```

- 考点：名字隐藏、作用域运算符 `::`。

### 3. 虚函数与非虚函数的区别

```cpp
class Base {
public:
    void f()    { cout << "Base::f" << endl; }
    virtual void g() { cout << "Base::g" << endl; }
};

class Derived : public Base {
public:
    void f()    { cout << "Derived::f" << endl; }
    void g() override { cout << "Derived::g" << endl; }
};

int main() {
    Derived d;
    Base *p = &d;
    p->f();   // 静态绑定：看指针类型，调用 Base::f
    p->g();   // 动态绑定：看实际对象类型，调用 Derived::g
}
```

运行结果：

```text
Base::f
Derived::g
```

---

## 十五、期末编程题（继承为主）的参考模板

假设题目：

> 定义一个基类 `Person`，包含姓名 name、年龄 age，以及显示信息的成员函数 `show()`；  
> 再定义派生类 `Student`，在 `Person` 的基础上增加学号 id，重写 `show()` 函数，在其中输出姓名、年龄和学号。  
> 在 `main` 函数中创建一个 `Student` 对象并输出其信息。

### 参考答案代码：

```cpp
#include <iostream>
#include <string>
using namespace std;

class Person {
protected:
    string name;
    int age;
public:
    Person(const string &name = "", int age = 0)
        : name(name), age(age) {}

    void setPerson(const string &n, int a) {
        name = n;
        age = a;
    }

    virtual void show() const {
        cout << "Name: " << name << ", Age: " << age;
    }

    virtual ~Person() {}  // 为多态基类写虚析构函数
};

class Student : public Person {
protected:
    string id;
public:
    Student(const string &name = "", int age = 0, const string &id = "")
        : Person(name, age), id(id) {}

    void setStudent(const string &n, int a, const string &i) {
        name = n;     // protected，所以子类可以直接访问
        age = a;
        id = i;
    }

    void show() const override {
        // 也可以先调用基类 show，然后追加
        // Person::show();
        // cout << ", ID: " << id << endl;

        cout << "Name: " << name
             << ", Age: " << age
             << ", ID: " << id << endl;
    }
};

int main() {
    Student s("Zhang San", 20, "20250001");
    s.show();

    // 多态调用示例
    Person *p = &s;
    p->show();  // 调用 Student::show（因为是虚函数）

    return 0;
}
```

该示例中集中出现了：

- 继承：`class Student : public Person`
- 访问控制：`protected` 成员在子类中可用
- 构造函数与初始化列表
- 虚函数、多态、虚析构函数

---

## 十六、最后总复习要点（按题型）

### 1. 选择题重点

1. 类和对象基本概念：实例、封装、抽象等。
2. `public / private / protected` 的含义和区别。
3. `const` 指针三种形式。
4. 构造函数的性质（无返回值、默认构造、拷贝构造、构造顺序）。
5. 继承方式对访问级别的影响（表要熟）。
6. 多态的条件和作用；虚函数、纯虚函数。
7. 运算符重载：语法、限制、常见重载形式。
8. 静态成员：共享性、必须在类外定义。
9. 析构函数及虚析构函数的意义。

### 2. 填空题常见空位

- 关键字：`class`，`public`，`private`，`protected`，`virtual`，`static`，`friend`，`const`，`override`，`= 0`。
- 概念句：构造函数、析构函数、多态、抽象类、继承等定义。

### 3. 写运行结果题

- 把构造/析构顺序写清楚，模拟程序执行过程。
- 注意虚函数与非虚函数的绑定方式。
- 注意同名函数隐藏和 `Base::f()` 的调用。

### 4. 程序设计题

- 正确写出：类定义 → 构造函数 → 继承关系 → 成员访问权限 → main 测试。
- 尽量写出 `virtual` 析构函数（会加印象分）。

---

考前建议：

- 把“继承访问级别变化那张表”默写一遍。
- 自己写一个含有虚函数、纯虚函数的基类和两个派生类，然后用基类指针数组存放派生对象，循环调用虚函数，确保完全理解多态。
- 再做 2～3 道构造/析构顺序输出题，见到类似题基本就稳了。
